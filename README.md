# operating-systems
## ФАЙЛОВЫЕ СИСТЕМЫ В UNIX-ПОДОБНЫХ ОС
1. Ознакомление с типами файлов исследуемой ФС. Применяя утилиту ls, отфильтрованы по одному примеру каждого типа файла используемой ФС. Комбинируя различные ключи утилиты рекурсивно просканировано все дерево, анализируя крайнюю левую позицию выходной информации полученной посредством ls –l. Написае скрипт.
2. Получены все жесткие ссылки на заданный файл, находящиеся в разных каталогах пользовательского пространства. Использована конвейеризация и фильтрация. Оформлено в виде скрипта.
3. Проанализированы все возможные способы формирования символьных ссылок, продемонстрированы экспериментально. Предложен скрипт, подсчитывающий и перечисляющий все полноименные символьные ссылки на файл, размещаемые в разных местах файлового дерева.
4. Получены все символьные ссылки на заданный в качестве входного параметра файл, не используя file.
5. Изучена утилита find, используя ее ключи, получена расширенная информация о всех типах файлов.
6. Проанализировано содержимое заголовка файла, а также файла-каталога с помощью утилит od и *dump. Если доступ к файлу-каталогу возможен, проанализировано изменение его содержимого при различных операциях над элементами, входящими в его состав (файлами и подкаталогами).
7. Определено максимальное количество записей в каталоге. Изменен размер каталога, варьируя количество записей (для этого создана программа, порождающая новые файлы и каталоги, а затем удаляющая их, предусмотрев промежуточный и конечный вывод информации о размере подопытного каталога).
8. Ознакомление с содержимым /etc/passwd, /etc/shadow, с утилитой /usr/bin/passwd, проанализированы права доступа к этим файлам.
9. Исследованы права владения и доступа, а также их сочетаемость

    9.1. Приведены примеры применения утилит chmod, chown к специально созданному для этих целей отдельному каталогу с файлами.

    9.2. Расширены права исполнения экспериментального файла с помощью флага SUID.

    9.3. Экспериментально установлено, как формируются итоговые права на использование файла, если права пользователя и группы, в которую он входит, различны.

    9.4. Сопоставлены возможности исполнения наиболее часто используемых операций, варьируя правами доступа к файлу и каталогу.
10. Разработана «программа-шлюз» для доступа к файлу другого пользователя при отсутствии прав на чтение информации из этого файла. Проведены эксперименты для случаев, когда пользователи принадлежат одной и разным группам. Результаты проанализированы.
11. Применяя утилиту df и аналогичные ей по функциональности утилиты, а также информационные файлы типа fstab, получена информация о файловых системах, возможных для монтирования, а также установленных на компьютере реально.

    11.1. Приведена информация об исследованных утилитах и информационных файлах с анализом их содержимого и форматов.

    11.2. Приведен образ диска с точки зрения состава и размещения всех ФС на испытуемом компьютере, а также образ полного дерева ФС, включая присоединенные ФС съемных и несъемных носителей. Проанализирован и указан формат таблицы монтирования.

    11.3. Приведено «максимально возможное» дерево ФС, проанализировано, где это указывается
12. Проанализирован принцип работы утилиты file.

    12.1. Приведен алгоритм её функционирования на основе информационной базы, размещение и полное имя которой указывается в описании утилиты в технической документации ОС, а также содержимого заголовка файла, к которому применяется утилита. Определено, где находятся магические числа и иные характеристики, идентифицирующие тип файла, применительно к исполняемым файлам, а также файлам других типов.

    12.2. Утилита file выполнена с разными ключами.

    12.3. Приведена экспериментальная попытка с добавлением в базу собственного типа файла и его дальнейшей идентификацией. 
## СИСТЕМНОЕ ПРОГРАММИРОВАНИЕ В ОС СЕМЕЙСТВА UNIX
1. Создана программа на основе одного исходного (а затем исполняемого) файла с псевдораспараллеливанием вычислений посредством порождения процесса-потомка.
2. Выполнены сначала однократные вычисления в каждом процессе. Каждый процесс имеет вывод на терминал, идентифицирующий текущий процесс. Последняя исполняемая команда  функции main выводит на терминал сообщение о завершении программы. Объяснены результаты.
3. Затем однократные вычисления заменены на циклы, длительность исполнения которых дотстаточна для наблюдения конкуренции процессов за процессорный ресурс.
4. ​Изменена процедура планирования и повторен эксперимент.
5. ​Разработана программа родителя и потомка с размещением в файлах father.c и son.c Для фиксации состояния таблицы процессов в файле использован системный вызов system("ps-abcde>file").
6. Запущена на выполнение программу father.out, получена информация о процессах, запущенных с терминала;
7. Выполнена программа father.out в фоновом режиме father&. Получена таблица процессов, запущенных с ерминала (включая отцовский и сыновний процессы).
8. Выполнено создание процессов с использованием различных функций семейства exec() с разными параметрами функций семейства, приведены результаты эксперимента.
9. Проанализино значение, возвращаемое фунецией wait(&status). Предложен эксперимент,позволяющий родителю отслеживать подмножество порожденных потомков, используя различные функции семейства wait().
10. Проанализирована очередность исполнения процессов.

    10.1. очередность исполнения процессов, порожденных вложенными вызовами fork().

    10.2. Изменена процедура планирования с помощью функции с шаблоном scheduler в ее названии и повторен эксперимент.

    10.3. Поменян  порядок очереди в RR-процедуре.
    
    10.4. Попытка задать разные процедуры планирования разным процессам с одинаковыми приоритетами. Экспериментально выяснено, как они будут конкурировать.
11. Определена величина кванта. Попытка ее поменять и обоснование эксперимента.
12. Проанализировано наследование на этапах fork() и exec (). Проведен эксперимент с родителем и потомками по доступу к одним и тем же файлам, открытым родителем.

### Взаимодействие родственных процессов
13.1. Изменяя длительности выполнения процессов и параметры системных вызовов, рассмотрены 3 ситуации и получены соответствующие таблицы процессов:
1) процесс-отец запускает процесс-сын и ожидает его завершения;
2) процесс-отец запускает процесс-сын и, не ожидая его завершения, завершает свое выполнение. Зафиксировано изменение родительского идентификатора процесса-сына;
3) процесс-отец запускает процесс-сын и не ожидает его завершения; процесс-сын завершает свое выполнение. Зафиксировано появление процесса-зомби, для этого включена команда ps в программу father.c

13.2. Перенаправлен вывод не только на терминал, но и в файл. Программа многопроцессного функционирования организована так, чтобы результатом ее работы была демонстрация всех трех ситуаций с отображением в итоговом файле.
### Управление процессами посредством сигналов
13.1. С помощью команды kill -l ознакомление с перечнем сигналов, поддерживаемых процессами. Знакомство с системными вызовами kill(2), signal(2).

Подготовлены программы следующего содержания:
1) процесс father порождает процессы son1, son2, son3 и запускает на исполнение программные коды из соответствующих исполнительных файлов;
2) далее родительский процесс осуществляет управление потомками, для этого он генерирует сигнал каждому пользовательскому процессу;
3) в пользовательских процессах-потомках необходимо обеспечить: для son1 - реакцию на сигнал по умолчанию; для son2 - реакцию игнорирования; для son3 - перехватывание и обработку сигнала.

    Сформирован файл-проект из четырех файлов. Проанализирована таблица процессов до и после посылки сигналов с помощью системного вызова system("ps -s >> file"). Обращено внимание на реакцию, устанавливаемую для последнего потомка.

13.2. Организована посылка сигналов любым двум процессам, находящимся в разных состояниях: активном и пассивном, фиксируя моменты посылки и приема каждого сигнала с точностью до секунды. Приведены результаты в файле результатов.

14. Запущено в фоновом режиме несколько утилит. Использование команды jobs для анализа списка заданий и очередности их выполнения. Уведомление о завершении одного из заданий организовано с помощью команды notify. Аргументом команды является номер задания. Невыполненные задания возвращены в приоритетный режим командой fg. Отменено одно из невыполненных заданий.
15. Знакомство с выполнением команды и системного вызова nice(1) и getpriority(2).Приведены примеры их использования в приложении. Определены границы приоритетов (для этого создана программа). Размышление над вопросами "Есть ли разница в приоритетах для системных и пользовательских процессов, используются ли приоритеты реального времени?", "Каков пользовательский приоритет для запуска приложений из shell?" Все ответы проверены экспериментально.
16. Знакомство с командой nohup(1). Запуск длительного процесс по nohup(1). Завершение сеанса работы. Снова вход в систему и проверка таблицы процессов. Пояснение результата.
17. Определение uid процесса, каково минимальное значение и кому оно принадлежит. Выяснено каково минимальное и максимальное значение pid, каким процессам ринадлежат? Проанализировано множество системных процессов, как их отличить от прочих, перечислено назначение самых важных из них.
### Многонитевое функционирование
18. Подготовлена программа, формирующая несколько нитей. Нити для эксперимента практически идентичны.
19. После запуска программы проанализировано выполнение нитей, распределение во времени. Попытка удалить нить, зная ее идентификатор, командой kill. Приведен и объяснен результат.
20. Программа изменена так, чтобы управление второй нитью осуществлялось посредством сигнала SIGUSR1 из первой нити. На пятой секунде работы приложения происходит удаление второй нити. Для этого использована функция pthread_kill(t2, SIGUSR); (t2 - дескриптор второй нити). Проанализированы полученные результаты.
21. Последняя модификация -- создание собственного обработчика сигнала, содержащего уведомление о начале его работы и возврат посредством функции pthread_exit(NULL); Сравнение результатов, полученных после запуска этой модификации программы с результатами предыдущей.
22. Перехватка сигнала «CTRL C» для процесса и потока однократно, а также многократно с восстановлением исходного обработчика после нескольких раз срабатывания.
23. С помощью утилиты kill выведен список всех сигналов и дана краткая характеристика на основе документации ОС. Для чего предназначены сигналы с 32 по 64-й. Приведен пример их применения.
24. Проанализирована процедура планирования для процессов и потоков одного процесса.

    24.1. Обоснован результат экспериментально.

    24.2. Попытка изменить процедуру планирования. Результат подтвержден экспериментально.

    24.3. Нитям заданы разные приоритеты программно и извне. Результат объяснен.
## IPC LINUX
1. Используя функцию sigaction(), продемонстрированы возможности управления линейкой сигналов, включая собственные обработчики и маскирование для разных сигналов, а также вариативность, предоставляемую структурами sigaction (act / oldact).
2. Реализованы надежные сигналы, организован эксперимент для доказательства отложенной обработки. Сгенерирована ситуация с несколькими отложенными сигналами.
3. Экспериментально продемонстрирована разница между надежными и ненадежным сигналами.
4. Организованы «вложенные» надежные сигналы, для этого из обработчика одного сигнала произведена отправка другого сигнала, а также отправка такого же сигнала.
5. Проведен эксперимент, доказывающий возможность организации очереди для различных типов сигналов, обычных и сигналов реального времени; Проверена возможность организации очереди для «вложенных» сигналов РВ.
6. Опытным путем подтверждено наличие приоритетов сигналов реального времени.
7. Экспериментально подтверждено, что обработка равно-приоритетных сигналов реального времени происходит в порядке FIFO.
## Межпроцессные взаимодействия. Разделение памяти, семафоры, сокеты, каналы.
8. Каналы: реализованы pipe 
9. fifo. Приведен в отчете фрагмент файла, содержащего ограничения для IPC (для каналов и сообщений).
10. Осуществлена передача информации посредством обмена сообщениями по принципу «почтового ящика», т.е. не синхронизируя отправителя и получателя (без ожидания доставки).
12. Выполнена передача информации локально посредством сокетов
по TCP/IP,
13. а затем в сетевом режиме (посредством сокетов по TCP/IP)
15. Выполнено аналогичное взаимодействие на основе UDP
17. Обеспечено разделение памяти между независимыми процессами и необходимая синхронизация для эффективного взаимодействия